import{_ as s,o as a,c as n,Q as p}from"./chunks/framework.00e71275.js";const F=JSON.parse('{"title":"开发小知识分享","description":"开发小知识分享","frontmatter":{"head":[["meta",{"name":"description","content":"开发小知识分享"}],["meta",{"name":"keywords","content":"css"}]]},"headers":[],"relativePath":"article/其他技术/开发小知识.md","filePath":"article/其他技术/开发小知识.md","lastUpdated":1667121428000}'),o={name:"article/其他技术/开发小知识.md"},l=p(`<h1 id="开发小知识分享" tabindex="-1">开发小知识分享 <a class="header-anchor" href="#开发小知识分享" aria-label="Permalink to &quot;开发小知识分享&quot;">​</a></h1><p>分享一些我所知道的容易踩坑的小知识点。</p><h2 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h2><h3 id="flex-布局下的弹性宽度处理" tabindex="-1">flex 布局下的弹性宽度处理 <a class="header-anchor" href="#flex-布局下的弹性宽度处理" aria-label="Permalink to &quot;flex 布局下的弹性宽度处理&quot;">​</a></h3><p>flex 布局是现在开发中使用的最多也是最主流的一个布局方式了，非常的好用，但是在一些特殊场景下，flex 布局会影响一些子元素的宽度，这时候就需要特殊的设置一些 API。</p><p><strong>涉及的 API</strong></p><ul><li><code>flex</code></li><li><code>width</code></li><li><code>max-width</code>、<code>min-width</code></li></ul><p><strong>背后的小故事</strong></p><p>有一天我在开发的时候，一个同事看我写了以下一段代码：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">// ... 省略以上的代码</span></span>
<span class="line"><span style="color:#B392F0;">.coupon</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">max-width</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">100</span><span style="color:#F97583;">px</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">min-width</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">100</span><span style="color:#F97583;">px</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">// ... 省略以上的代码</span></span>
<span class="line"><span style="color:#6F42C1;">.coupon</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#005CC5;">max-width</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">100</span><span style="color:#D73A49;">px</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#005CC5;">min-width</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">100</span><span style="color:#D73A49;">px</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>同事发表评论：为什么要写<code>max-width</code>和<code>min-width</code>，你这样和直接写<code>width</code>又有什么区别呢？</p><p>我：在<code>flex</code>布局下特殊情况直接写<code>width</code>是会有问题的。</p><p>同事：能有什么问题？</p><p>我：吧啦吧啦</p><p>之后同事是比较应付的说了哦，显然他不太愿意听我继续往下说，应付的回了一下我。之后也就没有再提这个了。</p><p><strong>到底直接写 width 会有什么问题呢？</strong></p><p>直接上一个案例吧~，一个很常见的一个布局，使用 flex 实现，效果大致如下（简单的画一下，大致意思应该能够表达到位了）</p><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220508135358722.png" alt="image-20220508135358722"></p><p>我们给立即使用的按钮设置了宽度为 80px，在左边的内容不是特别多的时候是能够正常的显示的，按钮也是 80px，没有一点儿问题~</p><p>但是当左侧的内容一多起来，由于 flex 布局的”弹性“的原因，就会去挤压左侧立即使用按钮的宽度，就会造成页面的形变，如果线上这样展示，无疑就是一个 bug！如下：</p><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220508135929926.png" alt="image-20220508135929926"></p><p>这种情况，我的解决方案就是，不再使用<code>width</code>来限定宽度，而是使用<code>max-width</code>和<code>min-width</code>一起限制宽度，这时候即使左侧文案再长，也不会去挤压到右侧的宽度，或者说，挤压不动右侧的宽度！</p><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220508140150877.png" alt="image-20220508140150877"></p><p>这个就是我解决<code>flex</code>布局宽度被挤压的问题的解决方式啦，就是使用<code>max-width</code>和<code>min-width</code>一起配合使用，替换<code>width</code>。</p><p>相信这个场景下应该还有其他的解决方案，如果有更好的解决方案的小伙伴们可以私信告诉我呀，或者直接分享出来，咱们大家一起学习一下~😋</p><p>小案例源码：<a href="https://github.com/ldlw/dailyLearning/tree/master/%E9%9A%8F%E6%89%8B%E8%AE%B0%E5%BD%95%E7%9F%A5%E8%AF%86%E7%82%B9/flex%E5%B8%83%E5%B1%80%E4%B8%AD%E5%AE%BD%E5%BA%A6%E8%AE%BE%E7%BD%AE" target="_blank" rel="noreferrer">传送门</a></p><p>感谢大家的观看，希望我的分享能够对你们有帮助！</p><p><strong>最新解决方案</strong></p><p>感谢一位老铁特地加我微信告诉了我一个更加优雅的实现方案：</p><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220525203212345.png" alt="image-20220525203212345"></p><p>右侧按钮设置：flex-shrink:0 或者左侧文案区域设置： flex:1</p><p>亲测有效，而且更加的优雅，今后都会使用这个方式来解决这个问题了！</p><h2 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-label="Permalink to &quot;JS&quot;">​</a></h2><h3 id="优雅的处理浮点数的加减法" tabindex="-1">优雅的处理浮点数的加减法 <a class="header-anchor" href="#优雅的处理浮点数的加减法" aria-label="Permalink to &quot;优雅的处理浮点数的加减法&quot;">​</a></h3><p>今天看到一个非常惊艳到我的一段代码，足足惊艳了半个多小时！代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">formatFloat</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">num</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">accuracy</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">num.</span><span style="color:#B392F0;">toFixed</span><span style="color:#E1E4E8;">(accuracy)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">formatFloat</span><span style="color:#24292E;">(</span><span style="color:#E36209;">num</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">, </span><span style="color:#E36209;">accuracy</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;">num.</span><span style="color:#6F42C1;">toFixed</span><span style="color:#24292E;">(accuracy)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这代码使用公司前辈写在公用工具库里的方法，第一眼看上去感觉也没什么了不起的，不就是<code>toFixed</code>方法可以四舍五入截取小数点位数嘛，但是我用了之后发现并没有那么简单：</p><p>大家可以先思考一下，大家可以想一下，这两种情况，返回值分别是什么：</p><ul><li><p>formatFloat(1.333334)</p><blockquote><p>是1.33吗？🤔</p></blockquote></li><li><p>formatFloat(1.2)</p><blockquote><p>1.20 ？🤔</p></blockquote></li><li><p>formatFloat(0)</p><blockquote><p>0.00 ? 🤔</p></blockquote></li></ul><p>以上我想的结果，实际情况下它的结果分别是：1.33、1.2、0。😱</p><p>奇怪了，它的<code>accuracy</code>不是默认是2吗，肯定会有2位小数点截取的呀，为什么传0的时候它返回的不是0.00？🤔</p><p>我开始怀疑我对<code>toFixed</code>的理解，然后开始在控制台写了一些测试代码。</p><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220706165746996.png" alt="image-20220706165746996"></p><p>发现确实是会有2位小数，研究了好一会儿也没有发现到底是为什么，于是我问了一下框架的作者。才知道原因...：😯</p><p><code>+num.toFixed()</code>前面加了一个<code>+</code>，<code>toFixed</code>的返回值是一个<code>string</code>类型，因为<code>+</code>的原因，会自动的将返回值转成一个number类型，&#39;0.00&#39;转正number类型就是0。</p><p>所以破案了🎉🎉，这段代码涉及隐式转换和执行顺序的知识。我理解的执行顺序是：<code>(+num).toFixed(2)</code>，可真正的执行顺序是：<code>+(num.toFixed(2))</code>。</p><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220706170214772.png" alt="image-20220706170214772"></p><p>现在回想起来我会认为执行顺序是<code>(+num).toFixed(2)</code>是因为只有数值类型才会有<code>toFixed</code>方法，这样理解是能兼容一些字符串的数字，当num是字符串的&#39;1.23&#39;时，页面就不会报错了，可是确忽略了，这是<code>TS</code>，num已经给了是一个<code>number</code>类型。🧐</p><p><strong>总结</strong></p><p>被这段代码经验到之后，知道了其实涉及隐式转换和执行顺序的基础知识还是很重要的，还有就是TS的重要性，这就是一个TS非常给力的场景！💪🏻💪🏻</p><h3 id="我终于搞懂了weakmap与map💪🏻" tabindex="-1">我终于搞懂了weakMap与Map💪🏻 <a class="header-anchor" href="#我终于搞懂了weakmap与map💪🏻" aria-label="Permalink to &quot;我终于搞懂了weakMap与Map💪🏻&quot;">​</a></h3><p>二者对标的数据类型都是对象类型 =&gt; 存储的键值对</p><p>我们要理解，为什么Vue3响应式系统使用的是weakMap而不是Map!</p><h4 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h4><ul><li><p>有更加优雅&amp;灵活的api用于增删改查</p></li><li><p>不会触发原型链的查找</p></li></ul><p>过去其实一直不知道map与weakMap的区别，或者说看过书面的官方解释，也背过面试题，知道weakMap存储的是弱类型的key，那么到底什么是弱类型(引用类型)的key呢？</p><p><strong>什么是弱类型</strong></p><p>我们都知道的字符串，数字这种属于值类型，弱类型我的简单理解就是、对象、函数。</p><p>所以基于这一点，我们就知道，weakMap的key只能是存弱类型，就不能存储字符串或者数字之类的作为key，而这个map可以</p><p><strong>不会发生内存溢出</strong></p><p>一个简单的例子过一下就能完全理解了！</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">map</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Map</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">wMap</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">WeakMap</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  (() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">foo</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">bar</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { bar: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    map.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(foo, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    map.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    wMap.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(bar, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// wMap.set(3, 1) // 报错，key必须是弱类型</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * WeakMap 是弱引用， 一旦表达式执行结束，垃圾回收就会把 bar 从内存中移除，所以无法从 weakMap中取到bar</span></span>
<span class="line"><span style="color:#6A737D;">     *  一旦被垃圾回收机制回收了，就无法获取到对应的 键和值了</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#E1E4E8;">  })()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(map, map.</span><span style="color:#B392F0;">keys</span><span style="color:#E1E4E8;">()) </span><span style="color:#6A737D;">// 依旧有办法获取 键和值</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(wMap) </span><span style="color:#6A737D;">// 已经无法获取键和值了，因为是弱引用，已经被垃圾回收机制所回收了</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">map</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Map</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">wMap</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">WeakMap</span><span style="color:#24292E;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  (() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">foo</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">bar</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { bar: </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    map.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(foo, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    map.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    wMap.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(bar, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// wMap.set(3, 1) // 报错，key必须是弱类型</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">     * WeakMap 是弱引用， 一旦表达式执行结束，垃圾回收就会把 bar 从内存中移除，所以无法从 weakMap中取到bar</span></span>
<span class="line"><span style="color:#6A737D;">     *  一旦被垃圾回收机制回收了，就无法获取到对应的 键和值了</span></span>
<span class="line"><span style="color:#6A737D;">     */</span></span>
<span class="line"><span style="color:#24292E;">  })()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(map, map.</span><span style="color:#6F42C1;">keys</span><span style="color:#24292E;">()) </span><span style="color:#6A737D;">// 依旧有办法获取 键和值</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(wMap) </span><span style="color:#6A737D;">// 已经无法获取键和值了，因为是弱引用，已经被垃圾回收机制所回收了</span></span></code></pre></div><p><strong>总结</strong></p><p>通过这个例子我算是比较清晰的理解了二者的区别了，已经在什么场景下对应应该使用哪种map来存储，比之前光看书去强行理解文字好多了。</p><p>知道了这个之后，set和weakSet也是一样的方式取理解即可！</p><p>最后应该可以很好回答上面的那个问题了，当一个响应式对象已经被垃圾回收机制所回收时，我们就不需要继续存储这个key-value了，这是一个性能优化的点，同时也能避免内存溢出！☀️</p>`,66),e=[l];function c(t,r,E,y,i,d){return a(),n("div",null,e)}const h=s(o,[["render",c]]);export{F as __pageData,h as default};
