import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.00e71275.js";const h=JSON.parse('{"title":"JS 高阶知识点 -- 持续更新","description":"高阶知识点","frontmatter":{"head":[["meta",{"name":"description","content":"高阶知识点"}],["meta",{"name":"keywords","content":"JS"}],["script",{"src":"https://vitepress-source.oss-cn-beijing.aliyuncs.com/statistics.js"}]]},"headers":[],"relativePath":"article/前端进阶/JS高阶知识点--持续更新.md","filePath":"article/前端进阶/JS高阶知识点--持续更新.md","lastUpdated":1668262405000}'),p={name:"article/前端进阶/JS高阶知识点--持续更新.md"},o=l(`<h1 id="js-高阶知识点-持续更新" tabindex="-1">JS 高阶知识点 -- 持续更新 <a class="header-anchor" href="#js-高阶知识点-持续更新" aria-label="Permalink to &quot;JS 高阶知识点 -- 持续更新&quot;">​</a></h1><p>逛稀土掘金看到的些好文章，记录的非常的详细，JS 高阶知识点。</p><h2 id="dom-元素节点的类型" tabindex="-1">DOM 元素节点的类型 <a class="header-anchor" href="#dom-元素节点的类型" aria-label="Permalink to &quot;DOM 元素节点的类型&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">元素节点            　　Node.</span><span style="color:#B392F0;">ELEMENT_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">属性节点            　　Node.</span><span style="color:#B392F0;">ATTRIBUTE_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">文本节点            　　Node.</span><span style="color:#B392F0;">TEXT_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">CDATA节点             Node.</span><span style="color:#B392F0;">CDATA_SECTION_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">实体引用名称节点    　　 Node.</span><span style="color:#B392F0;">ENTRY_REFERENCE_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">实体名称节点        　　Node.</span><span style="color:#B392F0;">ENTITY_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">处理指令节点        　　Node.</span><span style="color:#B392F0;">PROCESSING_INSTRUCTION_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">注释节点            　 Node.</span><span style="color:#B392F0;">COMMENT_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">文档节点            　 Node.</span><span style="color:#B392F0;">DOCUMENT_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">文档类型节点        　　Node.</span><span style="color:#B392F0;">DOCUMENT_TYPE_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">文档片段节点        　　Node.</span><span style="color:#B392F0;">DOCUMENT_FRAGMENT_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">11</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">DTD声明节点            Node.</span><span style="color:#B392F0;">NOTATION_NODE</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">元素节点            　　Node.</span><span style="color:#6F42C1;">ELEMENT_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">属性节点            　　Node.</span><span style="color:#6F42C1;">ATTRIBUTE_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">文本节点            　　Node.</span><span style="color:#6F42C1;">TEXT_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">CDATA节点             Node.</span><span style="color:#6F42C1;">CDATA_SECTION_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">实体引用名称节点    　　 Node.</span><span style="color:#6F42C1;">ENTRY_REFERENCE_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">实体名称节点        　　Node.</span><span style="color:#6F42C1;">ENTITY_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">6</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">处理指令节点        　　Node.</span><span style="color:#6F42C1;">PROCESSING_INSTRUCTION_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">7</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">注释节点            　 Node.</span><span style="color:#6F42C1;">COMMENT_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">文档节点            　 Node.</span><span style="color:#6F42C1;">DOCUMENT_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">9</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">文档类型节点        　　Node.</span><span style="color:#6F42C1;">DOCUMENT_TYPE_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">文档片段节点        　　Node.</span><span style="color:#6F42C1;">DOCUMENT_FRAGMENT_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">11</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">DTD声明节点            Node.</span><span style="color:#6F42C1;">NOTATION_NODE</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">12</span><span style="color:#24292E;">)</span></span></code></pre></div><h2 id="数组的-splice-与-slice-的区别" tabindex="-1">数组的 splice 与 slice 的区别 <a class="header-anchor" href="#数组的-splice-与-slice-的区别" aria-label="Permalink to &quot;数组的 splice 与 slice 的区别&quot;">​</a></h2><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>splice</td><td>splice(start, num, item1, item2, ...)</td><td>从 start 索引开始，截取 num 个元素，并插入 item1、item2 到原数组里，影响原数组</td></tr><tr><td>slice</td><td>slice(start, end)</td><td>从 start 开始，截取到 end - 1，如果没有 end，则截取到左后一个元素，不影响原数组</td></tr></tbody></table><h2 id="substr-和-substring-的区别" tabindex="-1">substr 和 substring 的区别？ <a class="header-anchor" href="#substr-和-substring-的区别" aria-label="Permalink to &quot;substr 和 substring 的区别？&quot;">​</a></h2><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>substr</td><td>substr(start,length)</td><td>返回从 start 位置开始 length 长度的子串</td></tr><tr><td>substring</td><td>substring(start,end)</td><td>返回从 start 位置开始到 end 位置的子串（不包含 end）</td></tr></tbody></table><h2 id="js-延迟加载的方法有哪些" tabindex="-1">JS 延迟加载的方法有哪些？ <a class="header-anchor" href="#js-延迟加载的方法有哪些" aria-label="Permalink to &quot;JS 延迟加载的方法有哪些？&quot;">​</a></h2><ul><li><p><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code> ：给 script 标签加 async 属性，则加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）</p></li><li><p><code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>：给 script 标签加 defer 属性，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成</p></li><li><p>动态创建 script 标签：等到<code>DOMContentLoaded</code> 事件触发时，生成一个 script 标签，渲染到页面上上</p></li><li><p>setTimeout 定时器延迟代码执行</p></li></ul><h2 id="异步脚本-defer-和-async-的区别" tabindex="-1">异步脚本 defer 和 async 的区别 <a class="header-anchor" href="#异步脚本-defer-和-async-的区别" aria-label="Permalink to &quot;异步脚本 defer 和 async 的区别&quot;">​</a></h2><ul><li>当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关。</li><li>当 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析。</li></ul><p>总结：defer 脚本是异步加载，但是执行时是等整个文档结束之后执行，async 脚本也是异步加载，但是执行是异步脚本加载完成之后就执行，执行的时候文档停止解析，等到脚本执行结束之后继续文档解析</p><h2 id="为什么-commonjs-不适用于浏览器" tabindex="-1">为什么 Commonjs 不适用于浏览器 <a class="header-anchor" href="#为什么-commonjs-不适用于浏览器" aria-label="Permalink to &quot;为什么 Commonjs 不适用于浏览器&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> math </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;math&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">math.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> math </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;math&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">math.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">)</span></span></code></pre></div><p>第二行 math.add(2, 3)，在第一行 require(&#39;math&#39;)之后运行，因此必须等 math.js 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p><p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于&quot;假死&quot;状态。</p><p>因此，浏览器端的模块，不能采用&quot;同步加载&quot;（synchronous），只能采用&quot;异步加载&quot;（asynchronous）。这就是 AMD 规范诞生的背景。</p><h2 id="commonjs-和-es6-module-的区别" tabindex="-1">Commonjs 和 ES6 Module 的区别 <a class="header-anchor" href="#commonjs-和-es6-module-的区别" aria-label="Permalink to &quot;Commonjs 和 ES6 Module 的区别&quot;">​</a></h2><ul><li>Commonjs 是拷贝输出，ES6 模块化是引用输出（更快，更适合浏览器）</li><li>Commonjs 是运行时加载，ES6 模块化是编译时输出接口</li><li>Commonjs 是单个值导出，ES6 模块化可以多个值导出</li><li>Commonjs 是动态语法可写在函数体中，ES6 模块化静态语法只能写在顶层</li><li>Commonjs 的 this 是当前模块化，ES6 模块化的 this 是 undefined</li></ul><h2 id="深度遍历与广度遍历的区别" tabindex="-1">深度遍历与广度遍历的区别 <a class="header-anchor" href="#深度遍历与广度遍历的区别" aria-label="Permalink to &quot;深度遍历与广度遍历的区别&quot;">​</a></h2><ul><li>深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大</li><li>深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点</li><li>深度优先采用的是堆栈的形式 即先进后出</li><li>广度优先则采用的是队列的形式 即先进先出</li></ul><h2 id="文档碎片" tabindex="-1">文档碎片 <a class="header-anchor" href="#文档碎片" aria-label="Permalink to &quot;文档碎片&quot;">​</a></h2><ul><li>是什么：一个容器，用于暂时存放创建的 dom 元素，使用<code>document.createDocumentFragment()</code>创建</li><li>有什么用：将需要添加的大量元素 先添加到文档碎片 中，再将文档碎片添加到需要插入的位置，大大减少 dom 操作，提高性能</li></ul><p>Jxue.js 吸收了这一点，当需要编译大段文本的时候，这个是个杀招！</p><h2 id="元素进入视口-intersectionobserver" tabindex="-1">元素进入视口 - IntersectionObserver <a class="header-anchor" href="#元素进入视口-intersectionobserver" aria-label="Permalink to &quot;元素进入视口 - IntersectionObserver&quot;">​</a></h2><p>案例：很长的页面底部有一个评论区，当出现评论区时需要显示评论区的回复框。</p><p>方案 1：大多数同学心里想的是不是和我一样需要计算页面的高度，当达到指定的高度时显示？</p><p>不足之处：这样其实是不好的，当页面是个多路由每个路由下都有评论区，且页面高度都不同的情况呢？每次都要计算？加上我们必须监听滚动条的滚动事件，由于滚动事件机密发生，就算加上防抖，计算量也很大，容器造成性能问题！！</p><p>方案 2：<strong>IntersectionObserver API</strong></p><blockquote><p>它的优点是不会引起重绘回流</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> div2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;div2&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IntersectionObserver</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">entries</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		entries.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">element</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(element)</span></span>
<span class="line"><span style="color:#E1E4E8;">			</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (element.isIntersecting) {</span></span>
<span class="line"><span style="color:#E1E4E8;">				</span><span style="color:#6A737D;">// element.isIntersecting 表示可见</span></span>
<span class="line"><span style="color:#E1E4E8;">				div1.innerText </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;我出来了&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">			} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">				div1.innerText </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;首页&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">			}</span></span>
<span class="line"><span style="color:#E1E4E8;">		})</span></span>
<span class="line"><span style="color:#E1E4E8;">	},</span></span>
<span class="line"><span style="color:#E1E4E8;">	{</span></span>
<span class="line"><span style="color:#E1E4E8;">		root: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">		threshold: [</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(div2) </span><span style="color:#6A737D;">// 监听 div2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> div2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;div2&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> observer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IntersectionObserver</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">entries</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">		entries.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">element</span><span style="color:#24292E;">, </span><span style="color:#E36209;">index</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">			console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(element)</span></span>
<span class="line"><span style="color:#24292E;">			</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (element.isIntersecting) {</span></span>
<span class="line"><span style="color:#24292E;">				</span><span style="color:#6A737D;">// element.isIntersecting 表示可见</span></span>
<span class="line"><span style="color:#24292E;">				div1.innerText </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;我出来了&#39;</span></span>
<span class="line"><span style="color:#24292E;">			} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">				div1.innerText </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;首页&#39;</span></span>
<span class="line"><span style="color:#24292E;">			}</span></span>
<span class="line"><span style="color:#24292E;">		})</span></span>
<span class="line"><span style="color:#24292E;">	},</span></span>
<span class="line"><span style="color:#24292E;">	{</span></span>
<span class="line"><span style="color:#24292E;">		root: </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">		threshold: [</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">],</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">observer.</span><span style="color:#6F42C1;">observe</span><span style="color:#24292E;">(div2) </span><span style="color:#6A737D;">// 监听 div2</span></span></code></pre></div><p>callback 函数的参数（entries）是一个数组，每个成员都是一个 IntersectionObserverEntry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。</p><ul><li><p>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</p></li><li><p>target：被观察的目标元素，是一个 DOM 节点对象</p></li><li><p>isIntersecting: 目标是否可见</p></li><li><p>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null</p></li><li><p>boundingClientRect：目标元素的矩形区域的信息</p></li><li><p>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</p></li><li><p>intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，</p></li></ul><h2 id="大数运算-bigint" tabindex="-1">大数运算（bigInt） <a class="header-anchor" href="#大数运算-bigint" aria-label="Permalink to &quot;大数运算（bigInt）&quot;">​</a></h2><p>JS 在正常情况下表示整数是有范围的，当超过最大值的时候就会触发精度问题。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Math.</span><span style="color:#B392F0;">pow</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">53</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">pow</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">53</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#6A737D;">// Math.pow(2, 53) =&gt; 9007199254740992</span></span>
<span class="line"><span style="color:#6A737D;">// Math.pow(2, 53) + 1 =&gt; 9007199254740992</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Math.</span><span style="color:#6F42C1;">pow</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">53</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">pow</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">53</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#6A737D;">// Math.pow(2, 53) =&gt; 9007199254740992</span></span>
<span class="line"><span style="color:#6A737D;">// Math.pow(2, 53) + 1 =&gt; 9007199254740992</span></span></code></pre></div><p>在上面的例子中，最多只能表示 9007199254740992 在这个基础上再加也没用。相信总会有计算特别大的数的需求，所以这时候我们就可以使用 <code>BigInt</code> 函数来处理。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">BigInt</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">pow</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">53</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BigInt</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">pow</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">53</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BigInt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">BigInt</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">pow</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">53</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BigInt</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">pow</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">53</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 报错 BigInt类型只能与BigInt类型相加  否则会有类型错误</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">BigInt</span><span style="color:#24292E;">(Math.</span><span style="color:#6F42C1;">pow</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">53</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BigInt</span><span style="color:#24292E;">(Math.</span><span style="color:#6F42C1;">pow</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">53</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BigInt</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">BigInt</span><span style="color:#24292E;">(Math.</span><span style="color:#6F42C1;">pow</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">53</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BigInt</span><span style="color:#24292E;">(Math.</span><span style="color:#6F42C1;">pow</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">53</span><span style="color:#24292E;">)) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 报错 BigInt类型只能与BigInt类型相加  否则会有类型错误</span></span></code></pre></div><h2 id="数字分隔符" tabindex="-1">数字分隔符 <a class="header-anchor" href="#数字分隔符" aria-label="Permalink to &quot;数字分隔符&quot;">​</a></h2><p>又是一个为和大数值打交道而产生的一个新的写法，让人眼前一亮！</p><p>在过去，如果我们要表示 100W，写法为 1000000</p><p>使用数字分隔符之后：</p><p>1_000_000</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">1000000</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1_000_000</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">1000000</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1_000_000</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// true</span></span></code></pre></div><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220506205812813.png" alt="image-20220506205812813"></p><h2 id="object-hasown" tabindex="-1">Object.hasOwn <a class="header-anchor" href="#object-hasown" aria-label="Permalink to &quot;Object.hasOwn&quot;">​</a></h2><p>这是一个比较新的 API，其要实现的目的和<code>in</code>、<code>Object.hasOwnProperty</code>是一样的，都是判断对象上是否存在于某个属性，区别在于，<code>Object.hasOwn</code>是目前为止最安全的一个 API！</p><ul><li><p><code>in</code> 操作符，会触发原型链的查找，这个容易出问题，也不够稳健，不推荐使用</p></li><li><p><code>Object.hasOwnProperty</code> 只会在当前的对象上查找，不会触发原型链的查找，相对稳健，但是在特殊的情况下也是会报错的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">hasOwnProperty</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;name&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// v报错</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">hasOwnProperty</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;name&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// v报错</span></span></code></pre></div></li><li><p><code>Object.hasOwn</code> 最推荐的一种 API，是上一种的升级版本，更适合于生产环境下，非常的稳健和靠谱</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> object </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { age: </span><span style="color:#79B8FF;">24</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">hasOwn</span><span style="color:#E1E4E8;">(object, </span><span style="color:#9ECBFF;">&#39;age&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> object2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">({ age: </span><span style="color:#79B8FF;">24</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">hasOwn</span><span style="color:#E1E4E8;">(object2, </span><span style="color:#9ECBFF;">&#39;age&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> object3 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">hasOwn</span><span style="color:#E1E4E8;">(object3, </span><span style="color:#9ECBFF;">&#39;age&#39;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// false</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> object </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { age: </span><span style="color:#005CC5;">24</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">hasOwn</span><span style="color:#24292E;">(object, </span><span style="color:#032F62;">&#39;age&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// true</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> object2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">({ age: </span><span style="color:#005CC5;">24</span><span style="color:#24292E;"> })</span></span>
<span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">hasOwn</span><span style="color:#24292E;">(object2, </span><span style="color:#032F62;">&#39;age&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> object3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">hasOwn</span><span style="color:#24292E;">(object3, </span><span style="color:#032F62;">&#39;age&#39;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// false</span></span></code></pre></div></li></ul>`,49),e=[o];function t(c,r,E,y,i,d){return a(),n("div",null,e)}const C=s(p,[["render",t]]);export{h as __pageData,C as default};
